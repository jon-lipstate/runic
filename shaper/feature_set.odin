package shaper

import "base:intrinsics"
// TODO: move to ttf??
// We cant use bit_set since we have 235 entries and it only holds 128
Feature_Set :: struct {
	bits: [4]u64,
}

create_feature_set :: proc(tags: ..Feature_Tag) -> Feature_Set {
	s := Feature_Set{}
	for t in tags {feature_set_add(&s, t)}
	return s
}

feature_set_add :: proc(set: ^Feature_Set, tag: Feature_Tag) {
	array_idx, bit_pos := feature_set_indexer(tag)
	set.bits[array_idx] |= 1 << bit_pos
}

// Remove a tag from the set
feature_set_remove :: proc(set: ^Feature_Set, tag: Feature_Tag) {
	array_idx, bit_pos := feature_set_indexer(tag)
	set.bits[array_idx] &= ~(1 << bit_pos)
}

// Check if tag is in the set
feature_set_contains :: proc(set: ^Feature_Set, tag: Feature_Tag) -> bool {
	array_idx, bit_pos := feature_set_indexer(tag)
	return (set.bits[array_idx] & (1 << bit_pos)) != 0
}
feature_set_try_add :: proc(set: ^Feature_Set, tag: Feature_Tag) -> (already_exists: bool) {
	array_idx, bit_pos := feature_set_indexer(tag)

	if array_idx < len(set.bits) {
		// Check if bit is already set
		already_exists = (set.bits[array_idx] & (1 << bit_pos)) != 0

		// Set the bit regardless
		set.bits[array_idx] |= 1 << bit_pos
	} else {
		when ODIN_DEBUG {panic("Lookup_Set Out of Bounds")}
	}

	return already_exists
}

// Union of two sets
feature_set_union :: proc(a, b: Feature_Set) -> Feature_Set {
	result := Feature_Set{}
	for i in 0 ..< len(a.bits) {
		result.bits[i] = a.bits[i] | b.bits[i]
	}
	return result
}

// Intersection of two sets
feature_set_intersection :: proc(a, b: Feature_Set) -> Feature_Set {
	result := Feature_Set{}
	for i in 0 ..< len(a.bits) {
		result.bits[i] = a.bits[i] & b.bits[i]
	}
	return result
}

// Difference of two sets (a - b)
feature_set_difference :: proc(a, b: Feature_Set) -> Feature_Set {
	result := Feature_Set{}
	for i in 0 ..< len(a.bits) {
		result.bits[i] = a.bits[i] & ~b.bits[i]
	}
	return result
}

count_feature_bits :: proc(set: Feature_Set) -> uint {
	count: u64 = 0
	for mask in set.bits {
		count += intrinsics.count_ones(mask)
	}
	return uint(count)
}
is_feature_set_empty :: proc(set: Feature_Set) -> bool {
	for mask in set.bits {
		if mask != 0 {
			return false
		}
	}
	return true
}

get_enabled_features :: proc(set: Feature_Set, allocator := context.allocator) -> []Feature_Tag {
	// Count features first to allocate the right size array
	count := count_feature_bits(set)
	if count == 0 {return nil}
	set := set // need ptr below
	features := make([dynamic]Feature_Tag, allocator)
	feature_index := 0

	// Iterate through all possible feature tags
	for feature in Feature_Tag {
		if feature_set_contains(&set, feature) {
			append(&features, feature)
		}
	}

	return features[:]
}

//////////////////////////////////////////////////////////////////////////////////////////
// Tag Indexers are generated by /encode_tags/meta.odin
// They represent 'perfect' hashes for tags to get compact encoding for tag sets
feature_set_indexer :: proc(tag: Feature_Tag) -> (array_index: int, bit_position: uint) {
	#partial switch tag {
	case .aalt:
		return 0, 1
	case .abvf:
		return 0, 2
	case .abvm:
		return 0, 3
	case .abvs:
		return 0, 4
	case .afrc:
		return 0, 5
	case .akhn:
		return 0, 6
	case .apkn:
		return 0, 7
	case .blwf:
		return 0, 8
	case .blwm:
		return 0, 9
	case .blws:
		return 0, 10
	case .calt:
		return 0, 11
	case .Case:
		return 0, 12
	case .ccmp:
		return 0, 13
	case .cfar:
		return 0, 14
	case .chws:
		return 0, 15
	case .cjct:
		return 0, 16
	case .clig:
		return 0, 17
	case .cpct:
		return 0, 18
	case .cpsp:
		return 0, 19
	case .cswh:
		return 0, 20
	case .curs:
		return 0, 21
	case .cv01:
		return 0, 22
	case .cv02:
		return 0, 23
	case .cv03:
		return 0, 24
	case .cv04:
		return 0, 25
	case .cv05:
		return 0, 26
	case .cv06:
		return 0, 27
	case .cv07:
		return 0, 28
	case .cv08:
		return 0, 29
	case .cv09:
		return 0, 30
	case .cv10:
		return 0, 31
	case .cv11:
		return 0, 32
	case .cv13:
		return 0, 33
	case .cv14:
		return 0, 34
	case .cv15:
		return 0, 35
	case .cv16:
		return 0, 36
	case .cv17:
		return 0, 37
	case .cv18:
		return 0, 38
	case .cv19:
		return 0, 39
	case .cv20:
		return 0, 40
	case .cv21:
		return 0, 41
	case .cv23:
		return 0, 42
	case .cv24:
		return 0, 43
	case .cv25:
		return 0, 44
	case .cv26:
		return 0, 45
	case .cv27:
		return 0, 46
	case .cv28:
		return 0, 47
	case .cv29:
		return 0, 48
	case .cv30:
		return 0, 49
	case .cv31:
		return 0, 50
	case .cv33:
		return 0, 51
	case .cv34:
		return 0, 52
	case .cv35:
		return 0, 53
	case .cv36:
		return 0, 54
	case .cv37:
		return 0, 55
	case .cv38:
		return 0, 56
	case .cv39:
		return 0, 57
	case .cv40:
		return 0, 58
	case .cv41:
		return 0, 59
	case .cv43:
		return 0, 60
	case .cv44:
		return 0, 61
	case .cv45:
		return 0, 62
	case .cv46:
		return 0, 63
	case .cv47:
		return 1, 0
	case .cv48:
		return 1, 1
	case .cv49:
		return 1, 2
	case .cv50:
		return 1, 3
	case .cv51:
		return 1, 4
	case .cv53:
		return 1, 5
	case .cv54:
		return 1, 6
	case .cv55:
		return 1, 7
	case .cv56:
		return 1, 8
	case .cv57:
		return 1, 9
	case .cv58:
		return 1, 10
	case .cv59:
		return 1, 11
	case .cv60:
		return 1, 12
	case .cv61:
		return 1, 13
	case .cv63:
		return 1, 14
	case .cv64:
		return 1, 15
	case .cv65:
		return 1, 16
	case .cv66:
		return 1, 17
	case .cv67:
		return 1, 18
	case .cv68:
		return 1, 19
	case .cv69:
		return 1, 20
	case .cv70:
		return 1, 21
	case .cv71:
		return 1, 22
	case .cv73:
		return 1, 23
	case .cv74:
		return 1, 24
	case .cv75:
		return 1, 25
	case .cv76:
		return 1, 26
	case .cv77:
		return 1, 27
	case .cv78:
		return 1, 28
	case .cv79:
		return 1, 29
	case .cv80:
		return 1, 30
	case .cv81:
		return 1, 31
	case .cv83:
		return 1, 32
	case .cv84:
		return 1, 33
	case .cv85:
		return 1, 34
	case .cv86:
		return 1, 35
	case .cv87:
		return 1, 36
	case .cv88:
		return 1, 37
	case .cv89:
		return 1, 38
	case .cv90:
		return 1, 39
	case .cv91:
		return 1, 40
	case .cv93:
		return 1, 41
	case .cv94:
		return 1, 42
	case .cv95:
		return 1, 43
	case .cv96:
		return 1, 44
	case .cv97:
		return 1, 45
	case .cv98:
		return 1, 46
	case .cv99:
		return 1, 47
	case .c2pc:
		return 1, 48
	case .c2sc:
		return 1, 49
	case .dist:
		return 1, 50
	case .dlig:
		return 1, 51
	case .dnom:
		return 1, 52
	case .dtls:
		return 1, 53
	case .expt:
		return 1, 54
	case .falt:
		return 1, 55
	case .fin2:
		return 1, 56
	case .fin3:
		return 1, 57
	case .fina:
		return 1, 58
	case .flac:
		return 1, 59
	case .frac:
		return 1, 60
	case .fwid:
		return 1, 61
	case .half:
		return 1, 62
	case .haln:
		return 1, 63
	case .halt:
		return 2, 0
	case .hist:
		return 2, 1
	case .hkna:
		return 2, 2
	case .hlig:
		return 2, 3
	case .hngl:
		return 2, 4
	case .hojo:
		return 2, 5
	case .hwid:
		return 2, 6
	case .init:
		return 2, 7
	case .isol:
		return 2, 8
	case .ital:
		return 2, 9
	case .jalt:
		return 2, 10
	case .jp78:
		return 2, 11
	case .jp83:
		return 2, 12
	case .jp90:
		return 2, 13
	case .jp04:
		return 2, 14
	case .kern:
		return 2, 15
	case .lfbd:
		return 2, 16
	case .liga:
		return 2, 17
	case .ljmo:
		return 2, 18
	case .lnum:
		return 2, 19
	case .locl:
		return 2, 20
	case .ltra:
		return 2, 21
	case .ltrm:
		return 2, 22
	case .mark:
		return 2, 23
	case .med2:
		return 2, 24
	case .medi:
		return 2, 25
	case .mgrk:
		return 2, 26
	case .mkmk:
		return 2, 27
	case .mset:
		return 2, 28
	case .nalt:
		return 2, 29
	case .nlck:
		return 2, 30
	case .nukt:
		return 2, 31
	case .numr:
		return 2, 32
	case .onum:
		return 2, 33
	case .opbd:
		return 2, 34
	case .ordn:
		return 2, 35
	case .ornm:
		return 2, 36
	case .palt:
		return 2, 37
	case .pcap:
		return 2, 38
	case .pkna:
		return 2, 39
	case .pnum:
		return 2, 40
	case .pref:
		return 2, 41
	case .pres:
		return 2, 42
	case .pstf:
		return 2, 43
	case .psts:
		return 2, 44
	case .pwid:
		return 2, 45
	case .qwid:
		return 2, 46
	case .rand:
		return 2, 47
	case .rclt:
		return 2, 48
	case .rkrf:
		return 2, 49
	case .rlig:
		return 2, 50
	case .rphf:
		return 2, 51
	case .rtbd:
		return 2, 52
	case .rtla:
		return 2, 53
	case .rtlm:
		return 2, 54
	case .ruby:
		return 2, 55
	case .rvrn:
		return 2, 56
	case .salt:
		return 2, 57
	case .sinf:
		return 2, 58
	case .size:
		return 2, 59
	case .smcp:
		return 2, 60
	case .smpl:
		return 2, 61
	case .ss01:
		return 2, 62
	case .ss02:
		return 2, 63
	case .ss03:
		return 3, 0
	case .ss04:
		return 3, 1
	case .ss05:
		return 3, 2
	case .ss06:
		return 3, 3
	case .ss07:
		return 3, 4
	case .ss08:
		return 3, 5
	case .ss09:
		return 3, 6
	case .ss10:
		return 3, 7
	case .ss11:
		return 3, 8
	case .ss12:
		return 3, 9
	case .ss13:
		return 3, 10
	case .ss14:
		return 3, 11
	case .ss15:
		return 3, 12
	case .ss16:
		return 3, 13
	case .ss17:
		return 3, 14
	case .ss18:
		return 3, 15
	case .ss19:
		return 3, 16
	case .ss20:
		return 3, 17
	case .ssty:
		return 3, 18
	case .stch:
		return 3, 19
	case .subs:
		return 3, 20
	case .sups:
		return 3, 21
	case .swsh:
		return 3, 22
	case .titl:
		return 3, 23
	case .tjmo:
		return 3, 24
	case .tnam:
		return 3, 25
	case .tnum:
		return 3, 26
	case .trad:
		return 3, 27
	case .twid:
		return 3, 28
	case .unic:
		return 3, 29
	case .valt:
		return 3, 30
	case .vapk:
		return 3, 31
	case .vatu:
		return 3, 32
	case .vchw:
		return 3, 33
	case .vert:
		return 3, 34
	case .vhal:
		return 3, 35
	case .vjmo:
		return 3, 36
	case .vkna:
		return 3, 37
	case .vkrn:
		return 3, 38
	case .vpal:
		return 3, 39
	case .vrt2:
		return 3, 40
	case .vrtr:
		return 3, 41
	case .zero:
		return 3, 42
	case:
		return 0, 0
	}
}
